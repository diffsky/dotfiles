# Determine if a git repo has uncomitted changes in it
parse_git_dirty() {
  # Requires git 1.8. ver 1.7 responds with "no changes added "
  [[ "$(git status 2> /dev/null | tail -n1 | cut -c 1-17)" != "nothing to commit" ]] && echo "*"
}

# Get the git branch name of current directory and wrap in parens if exists (for PS1)
parse_git_branch() {
  git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e "s/* \(.*\)/ (\1$(parse_git_dirty))/"
}

# echo git branch of current directory
get_git_branch() {
  git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/'
}

# git push origin branch
gpob() {
  git push origin $(get_git_branch)
}

# git pull origin branch
glob() {
  git pull origin $(get_git_branch)
}

# git fetch pull request
gfpr() {
  local remote='origin'
  if [ ! -z "$2" ];then
    remote=$2
  fi
  git show-ref --verify --quiet refs/heads/pr-$1
  if [ $? == 0 ];then
    echo "error: pr branch already exists"
    git checkout pr-$1
    return
  fi
  echo "attempting to fetch pull request for $remote pull/$1/head:pr-$1"
  git fetch $remote pull/$1/head:pr-$1
  git checkout pr-$1
}

# git fetch upstream pull request
gfpru() {
  if [ -z "$1" ];then
    echo "error: no pr number specified"
  else
    gfpr $1 "upstream"
  fi
}

# git unpublish branch
gunpb() {
  local oifs=$IFS
  IFS='/'
  local branch=($1)
  IFS=$oifs
  git push ${branch[0]} --delete ${branch[1]}
}

# rebase remote
glr() {
  git fetch origin && git rebase --preserve-merges origin/$(get_git_branch)
}

#  display file permissions in octal format
perms() {
  local input=*
  if [ ! -z "$1" ]; then
    input=$@
  fi
  if [ "$OS" == "Darwin" ]; then
    stat -f '%A %N' $input
  else
    stat -c '%A %a %n' $input
  fi
}

# Determine the active python virtualenv
# to add to PS1 use \$(parse_virtual_env)
parse_virtual_env() {
  if [ "$VIRTUAL_ENV" != "" ];then
    local env=`basename $VIRTUAL_ENV`
      echo " [$env]"
  fi
}

# Repeat a command mulitple times
repeat() {
  local n=$1
  shift
  while [ $(( n -= 1 )) -ge 0 ]
  do
    "$@"
  done
}

# Update and source .dotfiles
dotfiles() {
  if [ "$1" == "init" ];then
    local all='local'
    if [ "$2" == "all" ];then
      local all="all"
    fi
    $HOME/.dotfiles/init.sh $all
    return
  fi
  if [ "$1" == "remote" ];then
    echo "Attempting to merge from remote origin..."
    local owd=$PWD
    cd $HOME/.dotfiles
    git fetch origin
    git merge origin/master
    cd $owd
    mkdir -p $HOME/.ssh
    cp $HOME/.dotfiles/ssh/config* $HOME/.ssh
    if [ "$2" == "all" ];then
      $HOME/.dotfiles/init.sh all
      # this source needed here to apply changes
      source $HOME/.dotfiles/dotfiles/bashrc
      return
    fi
  fi
  source $HOME/.dotfiles/dotfiles/bashrc
  echo "sourced .dotfiles"
}

# remove known_hosts entry
unknow_host() {
  if [ -z "$1" ];then
    echo "error: missing hostname"
    return
  fi
  echo "removing host $1"
  ssh-keygen -R $1 &>/dev/null
  rm $HOME/.ssh/known_hosts.old 2>/dev/null
}

# cd to parent directory of symlinked file
cds() {
  local realpath=$(readlink $1)
  cd $(dirname "$realpath")
}

# make a directory and cd into it
md() {
  mkdir -p "$@" && cd "$@";
}
